---
title: "Primeros pasos en R"
author: "Martín Paladino"
date: "13 de mayo de 2017"
output:
  html_document:
    highlight: textmate
    number_sections: yes
    theme: journal
    toc: yes
---

Con R y Rstudio instalados estamos podemos empezar a interactuar con R, es decir, a pasar instrucciones escritas con R al intérprete de R. 

# Crear un proyecto. 

Los proyectos son una manera de organizar el trabajo: reúnen todos los archivos que necesitamos y, como si fuera poco, permiten grabar una imagen de nuestra sesión en el disco rígido. De ese modo podemos cerrar el programa y guardar el entorno completo, regresando más tarde al punto exacto en el que los habíamos dejado. 

Nuestro primer proyecto se llamará "tareas" y lo crearemos yendo al menú File->New Project y seleccionando después New Directory->Empty Project. Finalmente introducimos el nombre que queremos dar al proyecto, que será también el nombre de la carpeta. En este caso se llamará `tareas`. Podemos especificar en qué ubicación se creará esa carpeta. Recomiendo utilizar la carpeta DropBox, si es usuario del servicio. De ese modo no tendrá que preocuparse de hacer copias de seguridad. 

# Sintaxis de R: el argumento de las funciones. 

La forma más directa de empezar a usar R es usarlo como una calculadora. R incluye los operadores aritméticos usuales: `+`,`-`,`*`,`/`,`^`. En sentido estricto estos son operadores binarios: se ubican entre dos términos, uno a la izquierda y otro a la derecha. Las reglas de operación matemáticas usuales aplican, `2-1` restará una unidad a 2, no a la inversa. Los signos matemáticos, en sentido estricto, no existen en R. Ningún operador binario hace una operación, es una ayuda sintáctica que internamente se traduce en una función directamente ejecutable. Un *wrapper* o un envoltorio.  
Por ejemplo, `1+1` se traduce internamente como `sum(1,1)` y la función `sum()` resuelve el resultado. Una función llama a otra función y regresa el resultado como propio. 
En R sólo existen las funciones. R utiliza dos conceptos importantes del lenguaje matemático y los traduce a paradigmas de programación.  

1. La *Notación Polaca Invertida*, de acuerdo con la cuál separamos sintácticamente a los operadores de las magnitudes sobre las que se realiza la operación. En R señalamos la operación y luego `(entre paréntesis, separado por comas)` pasamos los argumentos de esa operación. Con frecuencia nuestro primer argumento son los datos. Si vamos a hacer un suma ¿Sobre qué números? Los restantes suelen ser opciones para la función, cuyos efectos se reportan en la ayuda de cada función. La función más importante de R es `help()`, una función que nos regresa como output la ayuda de otras funciones. Sólo ponga, entre comillas, el nombre de la función que le interesa. La ayuda está, en la mayoría de los casos, escrita en un inglés accesible. 
2. El cálculo lambda, de acuerdo con el cuál de las funciones importa más el input y el output que el nombre. Las funciones anónimas --unas que no tienen nombre-- pueden pasar su output a otra, lo que permite encadenar funciones y pasar el retorno de una como ingreso de la otra. R utiliza los paréntesis para dar orden a la ejecución de una forma similar a la notación matemática: las funciones anidadas se leen desde dentro hacia fuera, excepto si usamos tuberías del tipo de `%>%`. Las tuberías son una adquisición reciente de R y no forman parte del paquete básico. Vale la pena instalarlas, producen un código compacto, legible y consistente. 
Aún sin usar tuberías podemos hacer una macro función que encadena a muchas otras usando paréntesis. Más adelante veremos algunos ejemplos, lo importante es identificar el orden de los argumentos de una función y ubicar a las funciones en el lugar correcto. R Se encarga de ordenar la secuencia de ejecución. 
Esto incluye evaluaciones lógicas en el proceso. R evalua una expresión y dependiendo del resultado sigue uno u otro camino. Podemos abrir un brazo de procesamiento si el número de elementos de un vector es par y otro si es impar, como lo hicimos para el caso de la mediana. 
R es un lenguaje Touring completo: le podemos pedir aproximadamente todo lo que podemos pedir a una computadora. 

El primer uso que haremos de los paréntesis es tanto sintáctico de R como matemático. Para calcular el área de un círculo usamos pi por radio al cuadrado. Entonces tenemos que elevar el radio del círculo en cuestión al cuadrado y luego multiplicarlo por pi, que simplificaremos como 3.1416. En R lo resolvemos ubicando entre paréntesis la operación que se resolverá primero. Por ejemplo:  

```{r}
#Calcular el área de un círculo de 5 cm de radio.
3.1416*(5^2)
```

Pi es un número muy común en las matemáticas. Es conveniente tenerlo a mano y llamarlo de una manera más directa que capturarlo con el teclado cada vez que lo vamos a usar. Por eso R incluye una variable llamada `pi`, que cuando la invocamos nos regresa ese número. Como `pi` es una variable en el entorno la llamamos invocando su nombre sin comillas. 
Podemos hacer la operación anterior usando `pi` para invocar a $\pi$.

```{r}
pi*(5^2)
```

Lo mismo podemos hacer con el radio, sólo que como no es una variable de entorno debemos crearlo primero y asignarle un valor. En R no es estrictamente necesario crear una estructura de datos, asignarle un tipo y luego un valor, como lo haríamos en c. Estas tres operaciones se hacen al mismo tiempo y R infiere el tipo de dato que nos interesa. La combinación de caracteres `<-` (menor que seguido de guion medio) es el operador que R utiliza para asignar un nombre a un objeto. El objeto al que damos nombre es el output de una función y, a través del operador `<-`, los vinculamos. Los objetos 'bautizados' pueden ser convocados más tarde llamándolos por su nombre y no desaparecerán del entorno de trabajo a menos que  los eliminemos intencionalmente.    

```{r}
radio <- 5                  #Crea el objeto radio y le asigna el valor 5. R infiere que es numérico. 
radio_cuadrado <- radio^2   # Crea el objeto radio cuadrado al que asigna el resultado de la operación radio^2
pi*radio_cuadrado           #Multiplica pi por radio_cuadrado y nos muestra el resultado. No le asigna nombre. 
```
Es posible utilizar el signo  `=` para hacer la misma operación, asignar nombres. Sin embargo los manuales de estilo de R recomiendan usar `<-` por diversos motivos. El más importante es que podemos leerlo como una flecha que indica dónde quedará registrado el resultado. En `radio <- 5` queda claro que radio tomará el valor 5, en esa dirección apunta la flecha. Además es fácil confundir `=` y `==`, es último el evaluador lógico de igual. 

Tanto `pi` como `radio` son variables: objetos con un nombre asociado --asignado-- en los que podemos ubicar valores. Ambos tienen un sólo valor: son vectores de largo 1. Para crear un vector con un largo mayor podemos utilizar una función que se encarga de eso, se llama `c()`, por *concatenate* o concatenar: literalmente encadenar valores en una estructura más grande. `c()` se comporta como una típica función de R: un nombre seguido paréntesis y entre los paréntesis, separados por comas `,` los argumentos que pasamos a la función. La función procesa los argumentos y nos regresa el resultado. En el caso de `c()`  recibe varios valores unitarios u otros vectores y los convierte en un único vector. 
Los vectores son muy importantes en R porque nos facilitan los cálculos, especialmente porque podemos aprovechar sus atributos. Por ejemplo, un vector tiene como atributo un largo, que señala la cantidad de elementos que lo componen. En términos estadísticos diríamos que le largo de un vector es la $N$ y en R podemos acceder a su valor con la función `length(x)`, dónde `x` es un vector y el output es un vector numérico de largo 1. `length(length(x))==1` siempre debe regresarnos `TRUE`. 

```{r}
edad <- c(38, 39, 41, 27, 32) #Creo un vector numérico, le asigno el nombre edad.
length(edad)                  #Consulto el largo del vector edad.
edad+1                        #Suma 1 a cada elemento del vector edad.
sum(edad)                     #Sumatoria de todos los elementos del vector edad. 
sum(edad)/length(edad)        #Obtengo la media de edad: sumatoria de edad entre entre n de edad. 
sum(c(38, 39, 41, 27, 32))    #Anido funciones: R procesa desde dentro hacia afuera, primero resuelve c() y después sum(). 
```

`c()` es una función importante,`sum()` es otra que utilizaremos con frecuencia: nos regresa la sumatoria de los elementos de un vector numérico. 
Por supuesto, los vectores también aceptan otros tipos de datos, como las cadenas de caracteres. Podemos crear un un vector de cadenas de caracteres usando `c()` e introduciendo cada cadena entre paréntesis.
Todos los vectores tienen el un atributo llamado `names`, que no sirve para registrar los nombres (u otro metadato) de cada uno de los valores que allí guardamos. Siguiendo con el ejemplo de las edades, valdría la pena saber a qué personas corresponden. El problema es que si cargamos el nombre junto con el número ya no podremos obtener promedios, por R considerará que son caracteres y no números. 
Para eso es útil el atributo `names()` de los vectores, que nos permite agregar información sin tener alterar los datos originales. 
Para ver los nombres de un vector usamos la función `names()`. Si nuestro vector no tiene nombres asignados nos regresará `NULL`, es decir, un vector vacío. 
El atributo names() de un vector también es un vector. Entonces podemos crear un vector con los nombres --del mismo largo que el vector de las edades-- y luego asignarlo con `<-` al vector edad. 

```{r}
nombres <- c("Martín", "Andrea", "Iris", "Felipe", "Susana") #Creo el vector de caracteres nombres
nombres
names(edad) <- nombres                                        #Uso nombres como atributo del vector numérico edad. 
edad                                                          #Obtengo la edad y nombres emparejados
```
Una ventaja de usar el atributo `names()` es que después nos sirven de ayuda memoria para recuperar la información. En R recuperamos alguna información específica usando los corchetes `[]` después del nombre de la estructura de datos en la que estamos buscando. 
Piense en los corchetes como algo parecido a Google: en los corchetes introducimos una expresión y R nos regresa el resultado de la búsqueda. ¿Qué edad tendrá Martín?

```{r}
edad ["Martín"]              #Pongo el nombre entre paréntesis
edad["Martin"]               #Martin sin acento no existe en names de edad. Regresa NA: no disponible. 
edad [c("Andrea", "Iris")]   #Le puedo pasar un vector de términos de búsqueda. 
```

Otra forma de recuperar es un registro es por la ubicación. Los vectores son listas ordenadas, así que con el número de orden de un elemento podemos obtener el valor correspondiente. También podemos realizar búsquedas lógicas en la que R nos regresará todos los elementos que cumplen con algún requisito. 

```{r}
edad[5]               #Regresa el valor del 5to elemento de la lista.
edad[edad<35]         #Menores de 35 años. Repito el nombre del vector entre []!
edad[edad==41]        #Edad igual a 41 años. Usamos == para evaluar igualdad. 
```

# Manejo de más de un vector.

Para el análisis de datos los vectores son básicos, pero lo más interesante es su orden y longitud. Si dos vectores tienen el mismo orden y largo podemos hacer operaciones cruzadas: diferencias entre vectores, adiciones, correlaciones, modelos lineales. 
En nuestro ejemplo de las edades podríamos agregar los días desde nacido. En principio y de forma tosca podemos multiplicar cada edad por 365 y guardar el resultado en un vector, que tendrá el mismo orden y longitud del vector edad. 
 
```{r}
edad_dias <- edad*365     #Operación vectorial: multiplica cada elemento del vector por 365
edad_dias                 #Regresa el contenido del nuevo vector 
cor (edad, edad_dias)     #Correlación entre la edad... y la edad. Perfecta.

#Manipulación de cadenas de texto con paste(). Concatenación de texto. 
paste (names(edad["Martín"]), "escribió este texto cuando tenía", edad["Martín"], "años.") 
```

# Función para calcular una mediana con funciones primitivas de R. 

Demás está decir que para la mayoría de los casos no vamos a tener que crear las funciones para nuestros análisis. Sin embargo comprender las operaciones que hace un función nos ayuda mucho a entender la sintaxis de R. 
La mediana es una medida de tendencia central que indica el valor de la observación que divide a un vector ordenado por magnitud en dos partes iguales. Para vectores *de largo par* el primer paso es ordenar al vector por magnitud, el siguiente identificar el número de orden del valor central $\frac{n+1}{2}$ y el tercero extraer el valor que corresponde a ese número de índice. Sumamos 1 a la n para que se convierta en un número par que, dividido entre 2, tiene resto 0.

```{r}
#Paso a paso
#=============

edad_ordenada <- sort(edad)               #Con la función sort creo una versión ordenada del vector edad, le asgino el nombre edad_ordenana
largo_menos_1 <- length(edad_ordenada)+1  #Obtengo la n, a la que resto 1 para hacerla par. 
ubicacion <- largo_menos_1/2
ubicacion
edad_ordenada [ubicacion]
edad_ordenada[3]

#En un solo paso. R resuelve el orden ejecución interpretando los paréntesis y corchetes.
sort(edad)[(length(sort(edad))+1)/2]
```
# Manejo de data.frame.

Los vectores son muy útiles, pero sería penoso tener que manejar decenas o cientos de vectores resultantes de la codificación de un cuestionario. En ese caso cada pregunta será registrada como un vector y, para complicar aún más las cosas, posiblemente tengan tipos diferentes. R tiene una estructura de datos perfecta para este tipo de información: el `data.frame`. Un `data.frame` reúne múltiples vectores en una estructura rectangular, todos bajo el mismo nombre. Sin embargo cada vector también tiene uno, así que podemos llamar a un data.frame y dentro del mismo a uno de sus vectores. En este rectángulo tanto filas como columnas pueden ser extraídas como vectores, aunque la mayor parte del trabajo se dedica a las columnas. Esto se debe a que, por convención, en las columnas se ubican las variables y en las filas las observaciones. 
Como ahora tenemos dos dimensiones el uso que dimos a los corchetes ya no funciona: tenemos que pasar dos coordenadas para ubicar un registro: fila y columna. Y así lo hacemos y en ese orden, usando una coma como separador. 



# Sobre los archivos de sintaxis. 

Aunque los proyectos y la restauración de sesión son muy útiles para continuar el trabajo, es una buena práctica trabajar directamente con archivos en los que guardamos los scripts. En lugar de guardar nuestros outputs guardamos el código que los producen. De este modo nuestros productos de investigación son *reproducibles*: con el mismo software libre otra persona en otra computadora puede obtener los mismos resultados. 
R utiliza la extensión `.r` para los archivos con guiones de R. Todos los archivos con esa extensión serán considerados directamente ejecutables dentro del entorno de R.
Dentro de Rstudio podemos ejecutar una línea de código o una parte a la que hemos resaltado utilizando la combinación `Ctrl-Enter`.


