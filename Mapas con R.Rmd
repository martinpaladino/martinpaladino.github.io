---
title: "Mapas con ggplot"
author: "Martín Paladino"
date: "27 de febrero de 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Introducción 

##Nota sobre la información geográfica del INEGI y los sistemas de coordenadas. 

El INEGI tiene puestos a disposició del público shapefiles con distintos niveles de información. Sin considerar los históricos esta información se regular por el Marco Geoestadístico Censal, cuya última versión es de 2016. Incluye las siguientes divisiones y subdivisiones del territorio: 

Table: Subdividivisiones territoriales básicas del INEGI. 

Código | División    | Unidades territoriales
-------|-------------|------------------------
AGEE   | Estatales   | 32
AGEM   | Municipales | 2458
AGEB   | Censal      | 17470
PLUR   | Localidades | 49498

Nota aparte merece el sistema de coordenadas que utiliza INEGI, también definido en el el Marco Geoestadístico Censal 2016. La definición técnica es  MEXICO_ITRF_2008_LCC, con proyección Cónica Conforme de Lambert  (CCL) y datum es ITRF2008. Se trata de un sistema de coordenadas rectangular, cuya unidad de medida es el *metro*. Esta cuadricula cubre el espacio entre los paralelos 17.5N y 29.5N con el meridiano 102 como centro. En términos prácticos esto tiene alguas implicaciones: 

- La cartografía que generemos a partir de shapefiles del INEGI se expresa directamente en una proyección ad hoc para México. Por lo tanto:
    - Podemos esperar mapas con pocas deformaciones. 
    - Al utilizar unidades rectas para expresar la distancia (y no grados, minutos, segundos, unidades de arco) es fácil interpretar la escala de nuestros gráficos. Esta es razonablemente homogenea.  
    - La mayor parte de la información geográfica que producen las instituciones gubernamentales de México (INEGI, CONAPO, CONABIO, etc.) utiliza este mismo marco de referencia, por lo que podemos combinar estas capas sin mayores inconvenientes. El INE es un caso aparte, su sistema de información geográfica es diferente. 
    
- Sin embargo otras capas de información geográfica pudieramos aprovechar y que se produce fuera de la órbita de estas instituciones suele estar expresada en otro sistema de coordenadas. Por ejemplo, en unidades hexadecimales de arco, es decir, latitud y longitud medidas en grados, minutos y segundos. Por lo tanto:
    - No podemos unir esas capas sin una transformación previa, de lo contrario la ubicación de los polígonos no va a ser compatible. 
        - Debemos llevar la información no INEGI al sistema de INEGI o viceversa. 
            - INEGI dispone de una app en línea para convertir información en Lat Long a lcc en http://www.inegi.org.mx/geo/contenidos/geodesia/traninv.aspx. Hasta ahora no he visto una opción para convertir una base de puntos datos completa y mucho menos polígonos. Debemos transformar punto por punto. 
            - No encontré una función o librería en R que nos permita hacer este traspaso de manera simple, aunque no he sido exhaustivo en la búsqueda. 
        - http://www.gadm.org/ dispone de shapefiles y objetos geoespaciales SPDF de R (.rds) de México, subdivididos hasta nivel municipal con un sistema de coordenadas geográficas. Se trata de archivos pequeños que se cargan directamente en R sin necesidad de importación. Sin embargo no dispone de unidades territoriales menores al municipio, red caminera, áreas y recursos naturales ,etc. y no es fuente oficial. Tampoco podemos estar completamente seguros de su actualización. Úselo bajo su propia responsabilidad.  
    - La cartografía de google maps está disponible a través de una API y R tiene varios clientes para esa API. El problema señalado de los diferentes sistemas de coordenadas dificulta su aprovechamiento. 
    - R tiene la librería `mapproj::` para proyección de mapas y ggplot nos permite utilizarla facilmente con `coord_map()`. Sin embargo esta librería sólo admite coordenadas geográficas, por lo que no podemos utilizarla con datos crudos del INEGI. 
    
#Mapas coropléticos de México con R.  

Este es un primer intento de generar cartografía a partir de R. 


##Unidad territorial: Estados. 

Vamos a utilizar al Estado como unidad territorial, para mantener las cosas simples y reducir el tiempo de procesamiento. 

-Instalamos la librería `rgdal`, que tiene la función `readOGR` para cargar shapefiles en R y convertirlos en un objeto espacial de R.  

- Descargamos desde acá http://www.conapo.gob.mx/es/CONAPO/Datos_Abiertos_del_Indice_de_Marginacion los datos de marginación del CONAPO a nivel municipal. Se pueden agregar por Estados. 

- Descagamos los shapefiles del Marco Geoestadístico 2016 del sitio del INEGI (202MB) desde este enlace:  http://internet.contenidos.inegi.org.mx/contenidos/productos//prod_serv/contenidos/espanol/bvinegi/productos/geografia/marc_geo/702825217341_s.zip 

- Descomprimimos **todos** los archivos del .zip en el directorio de trabajo. 
    - Usamos `getwd()` para saber cuál es nuestro directorio de trabajo. 

###Importación de capas y mapas simples.

```{r}
library(rgdal)
library(tidyverse)

#Cargo el shapefile de los estados y lo asigno a capa_estados.
#"." es el directorio, layer="Estados" el archivo .shp, pero sin la extensión, ya que readOG

capa_estados <-readOGR(".", layer="Estados")

#¿Qué habrá acá dentro?

class(capa_estados) 

#str(capa_estados) Demasiado largo, supera a la consola. 

capa_estados$NOM_ENT #Con sensacionales errores de codificación!
capa_estados$CVE_ENT #Este es el que sirve. 

#A ver...
ggplot() +  
  geom_polygon(data=capa_estados, aes(x=long, y=lat, group=group))
#Latitudd y longitud Marco Geográfico INEGI.

#Con los contornos de los estados. 
ggplot() +  
  geom_polygon(data=capa_estados, aes(x=long, y=lat, group=group), 
               fill="white", color="black") #Simplemente pasé las líneas a negro y el relleno a blanco fuera de aes(). 


```

Obtuvimos un mapa completo de México. Valdría la pena hacer un mapa coroplético en l que coloreamos a cada Estado  por la media de Marginación Municipal. 

###Colorear los Estados por la media del IM. Con join. Más complejidad, más control.

El elemento geométrico primitivo que ggplot2 utiliza para generar mapas a partir de polígonos --como los que importamos desde shapefiles-- es `geom_polygon()`. El data.frame resultante de la conversión de un objeto SPDF es sumamente largo, tiene una fila por cada cambio en un polígono y un columna de grupo para separar cada polígono. Para un mapa coroplético podriamos usar el argumento `fill=` para los polígonos. Antes debemos resolver el problema de las estructuras de datos. Por el momento la información geográfica está en una estructura de lista -no data.frame- y tiene una entrada por cada curva en los polígonos. Es decir, debemos pasar el objeto SPDF a data.frame y encontrar la manera de compatibilizar dos estructuras de datos con largos diferentes: la del mapa con un fila por cada curva de polígono y la de las medias del Índice de Marginación, con 32 filas, una por cada Entidad Federativa. 
Haremos lo siguiente: 

1. Crear un data frame con el sumario estadístico, en este caso las medias por entidad. Deberá incluir una clave en común el data.frame de polígonos. 
2. Convertir el objeto SPDF a data.frame.
3. Aplicar un join para unir ambas estructuras de datos. El dato de interés que controlará el color se repetirá una vez por cada fila, de modo que los largos sean iguales. `dplyr::inner_join()` se encarga de hacerlo. 
4. Producir el mapa con el elemento geométrico `geom_polygon()`, agregando un argumento `fill()`

```{r, error=T}
#Cargo la base de marginación y la limpio. 
marginacion <- read_csv("C:/Users/mpaladino/Dropbox/martinpaladino.github.io/datos/Base_Indice_de_marginacion_municipal_90-15.csv", 
    col_types = cols(`AÑO` = col_character()), 
    locale = locale(encoding = "UTF-8")) %>%  
      mutate (POB_TOT=gsub(" ","", POB_TOT)) %>%
      mutate(POB_TOT=as.integer(POB_TOT)) %>%
      filter(ENT!="Nacional")

#Obtengo las media de IM para 2015. 
marginacion %>%
  filter(AÑO=="2015") %>% 
  group_by(CVE_ENT, ENT) %>% 
  summarise (mediaIM=mean(IM)) %>% 
  mutate(id=CVE_ENT) -> #Renombre CVE_ENT a id para que coincida con el nomnre de columna del data.frame de los polígonos. 
  mediaIM

mediaIM

#Un df de 32x4 con "id" igual al SPDF.

#Paso el objeto SPDF a data.frame con `fortify()`, una función de ggplot2 con métodos para convertir objetos diversos a data.frame.

capa_estados_df <- fortify(capa_estados, region="CVE_ENT") #region="CVE_ENT", el agrupamiento de los polígonos. Coincide en nombre y contenido con mediaIM$id.    

capa_estados_df_mediaIM <- inner_join(capa_estados_df, mediaIM, by="id") #Uno las medias con los polígonos por la variable clave: id.

head(capa_estados_df_mediaIM)   #La media se repite una vez por punto de polígono, unidas por id. 

ggplot(capa_estados_df_mediaIM) +  
  geom_polygon(aes(x=long, y=lat, 
                   group=group,      #El argumento group=group arma grupos tanto para para los polígonos como para `fill=`. 
                   fill=mediaIM))    #Aquí especifico la columna que controla los colores. 
```

###Colorear los Estados por la media del IM. Con `geom_map()` 

ggplot2 tiene un elemento geométrico específico para generar mapas. Usa el primitivo `geom_polygon()`, como lo hicimos en el ejercicio anterior, pero permite especificar directamente el mapa y automatiza el manejo de múltiples estructuras de datos. Por lo tanto no es necesario hacer unir previamente las estructuras de datos. Esto simplifica la   

```{r}
#Crear un data.frame con los polígonos, incluyendo "CVE_ENT"
library(rgeos) #La requiere. Ver http://stackoverflow.com/questions/30790036/error-istruegpclibpermitstatus-is-not-true  

#Retomo las estructuras de datos que ya cree: capa_estados_df y mediaIM. 

#Sintaxis de geom_map.

ggplot(mediaIM,                          #Los datos que pasamos a ggplot son el resumen estadístico de intereés, NO el mapa.  
       aes(map_id = id)) +               #map_id es la columna con la clave de unión. Nos ahorra el join previo. 
    geom_map(aes(fill = mediaIM),        #fill= columna que controla el color.
             map = capa_estados_df) +    #map= objeto SPDF convertido a data.frame. 
  expand_limits(x = capa_estados_df$long, y = capa_estados_df$lat)  #Especificamos el tamaño del mapa al máximo de lat y long.
```

Obtuvimos el resultado que buscábamos y el un mapa explortorio aceptable. Sin embargo podemos mejorarlo usando la sintaxis usual de ggplot2. Esta es la gran ventaja de usar una misma librería para todos nuestros gráficos: conociendo una sintaxis podemos modificar muchos tipos de gráficos, incluyendo mapas. Además podemos aplicar el mismo estilo visual. 
En este caso usaremos `dplyr::` y `ggplot2::` para ajustar el gráfico. 

1. Creando datos más pertinentes. Media de IM municipal ponderada por población. 
2. Agregando una escala de distancia. Aprovechamos la proyección definida por INEGI, que en para el territorio mexicano es plana y está expresada en unidad de medida métrica. Esto no aplica de manera directa para cartografía generada a partir de coordenadas geográficas.  
3. Ubicando la leyenda de colores, con el título bien formateado, en el Golfo de México, para aprovechar mejor el espacio. 
4. Usando el código de colores semáforo, donde rojo marca una advertencia. 

```{r}

marginacion %>%
  filter(AÑO=="2015") %>% 
  group_by(CVE_ENT, ENT) %>% 
  summarise (`Media IM \nPonderada por\npoblación` =     #Uso \n para insertar directamente saltos de línea
               weighted.mean(IM, POB_TOT)) %>%           #weighted.mean() Media ponderada
  mutate(id=CVE_ENT) ->
  mediaIM

ggplot(mediaIM, aes(map_id = id)) + 
  geom_map(aes(fill = `Media IM \nPonderada por\npoblación`), map = capa_estados_df) + 
  expand_limits(x = capa_estados_df$long, y = capa_estados_df$lat) +
  scale_fill_continuous(low="green", high="red") +                           #Cambio la escala contínua de colores.
  labs(title="Media del Índice de Marginación Municipal por Estados 2015",   #Las anotaciones con la sintaxis usual de ggplot2::
       subtitle="Ponderado por población", 
       caption="Elaboración propia. \n Datos geográficos: INEGI 2016. \n Datos de estadísticos: CONAPO 2015") +
  theme_void() +                                                             #Elimina escalas, marcas de coordenadas, etc. 
  geom_errorbarh(aes(x=1.5e6, xmin=1.5e6-1e5, xmax=1.5e6+1e5, y=1e6), height=5e4) + #Uso una barra de error horizontal para la escala
  annotate("text", x= 1.5e6, y=1.0e6+8e4, label="200km", size=2) +           #Nota de la escala +- 100000 metros=200km. 
  theme(legend.position = c(0.8, 0.7))                                       #Ubico la leyenda dentro del gráfico en una zona vacia.
```

##Con coordenadas geográficas de http://www.gadm.org/. 
Global Administrative Areas tiene objetos SPDF --formato nativo de R-- con polígonos administrativos de prácticamente todos los países del mundo con sistema de coordenadas geográficas . Al estar en formato de R no es necesario  importarlo, simplemente los cargamos a R. El proceso es más rápido.

```{r}
#Importo y preparo los datos
#===========================

library(rgdal)
library(rgeos)   #Creo que no hace falta...
library(mapproj) #Para cambiar las proyecciones. 

estados_poly <- readRDS("MEX_adm1.rds") #Directo a R. 
estados_df <- fortify(estados_poly)     #Lo paso a data.frame
marginacion <- read_csv("C:/Users/mpaladino/Dropbox/martinpaladino.github.io/datos/Base_Indice_de_marginacion_municipal_90-15.csv", 
    col_types = cols(`AÑO` = col_character()), 
    locale = locale(encoding = "UTF-8")) %>%  
      mutate (POB_TOT=gsub(" ","", POB_TOT)) %>%
      mutate(POB_TOT=as.integer(POB_TOT)) %>%
      filter(ENT!="Nacional")


marginacion %>%
  filter(AÑO=="2015") %>% 
  group_by(CVE_ENT, ENT) %>% 
  summarise (mediaIM=mean(IM)) %>% 
  mutate(id=as.numeric(CVE_ENT)) -> #Nótese que as.numeric. else los 10 primeros estados no plotean. 
  mediaIM

ggplot(mediaIM, aes(map_id = id)) + 
    geom_map(aes(fill = mediaIM), 
             map = estados_df) + 
    expand_limits(x = estados_df$long, y = estados_df$lat) + 
  theme_minimal() +
  labs(title="Proyección Mercator") #Funciona. Van en serie. 


ggplot(mediaIM, aes(map_id = id)) +   
    geom_map(aes(fill = mediaIM), 
             map = estados_df) + 
    expand_limits(x = estados_df$long, y = estados_df$lat) + 
  coord_map ("cylindrical") + 
  theme_void() + 
  labs(title="Proyeccción cilíndrica")

ggplot(mediaIM, aes(map_id = id)) +   
    geom_map(aes(fill = mediaIM), 
             map = estados_df) + 
    expand_limits(x = estados_df$long, y = estados_df$lat) + 
  coord_map ("gilbert") + 
  theme_void() + 
  labs(title="Proyeccción Gilbert")

ggplot(mediaIM, aes(map_id = id)) +   
    geom_map(aes(fill = mediaIM), 
             map = estados_df) + 
    expand_limits(x = estados_df$long, y = estados_df$lat) + 
  coord_map ("lagrange") + 
  theme_void() + 
  labs(title="Proyeccción Lagrange")

#Con paneles. 

marginacion %>%
  filter(AÑO=="2015") %>% 
  group_by(CVE_ENT, ENT) %>% 
  summarise (`mediaPL>5000`=mean(`PL<5000`), mediaANALF=mean(ANALF), mediaPO2SM=mean(PO2SM), mediaOVSAE=mean(OVSAE)) %>% 
  mutate(id=as.numeric(CVE_ENT)) %>% 
  ungroup () %>% 
  select(-CVE_ENT) %>% 
  gather(., clave, valor, -id, -ENT) ->   mediaIM

ggplot(mediaIM, aes(map_id = id)) +   
    geom_map(aes(fill = valor), map = estados_df) + 
    expand_limits(x = estados_df$long, y = estados_df$lat) + 
  facet_wrap(~clave) +
  scale_fill_continuous(low="green", high="red") + 
  theme_void()
```


##Unidad territorial: Municipios de Tlaxcala. 

```{r}
library(ggrepel)
#Primer paso: cargar el shapefile de Tlaxcala con polígonos municipales. 

tlaxcala_poly <- readOGR(".", "tlax_municipal")
tlaxcala_df <- fortify(tlaxcala_poly, region="CVEGEO")

marginacion_tlaxcala <-read_csv("C:/Users/mpaladino/Dropbox/martinpaladino.github.io/datos/Base_Indice_de_marginacion_municipal_90-15.csv", 
    col_types = cols(`AÑO` = col_character()), 
    locale = locale(encoding = "UTF-8")) %>%  
      mutate (POB_TOT=gsub(" ","", POB_TOT)) %>%
      mutate(POB_TOT=as.integer(POB_TOT)) %>%
      filter(AÑO=="2015" & CVE_ENT=="29")

names(marginacion_tlaxcala) [1] <- "id" #Coincide con el id de los polígonosPorque filter (o tibble o los dos) complican la cadena con el nombre de la primera variable. Investigar y reportar el bug. si no iría directamente un mutate(), pero falla.

#Validación de polígonos. 
ggplot() +  
  geom_polygon(data=tlaxcala_poly, aes(x=long, y=lat, group=group), 
               fill="white", color="black") + 
  labs(title="Municipios de Tlaxcala", 
       subtitle="Validación de polígonos lat long") +
  theme_minimal() 

ggplot() +  
  geom_polygon(data=tlaxcala_poly, aes(x=long, y=lat, group=group), 
               fill="white", color="black") + 
  geom_point(aes(
    x=as.data.frame(coordinates(tlaxcala_poly))$V1, #coordinates estima los centroides de cada polígono. Anda mejor en Wyoming...  
    y=as.data.frame(coordinates(tlaxcala_poly))$V2)) + 
  labs(title="Municipios de Tlaxcala", 
       subtitle="Proyección Lagrange") +
  theme_minimal() + coord_map("lagrange")

#Coroplético por IM. 

ggplot(marginacion_tlaxcala, aes(map_id = id)) +  
  geom_map(aes(fill = IM), 
             map = tlaxcala_df) +  
  expand_limits(x = tlaxcala_df$long, y = tlaxcala_df$lat) + 
  coord_map("lagrange") + 
  theme_minimal() + 
  scale_fill_continuous(low="green", high="red")

#Etiquetado con Nombre de Municipio. 
#La función coordinates() regresa coordenadas x y del centroide de cada polígono, aunque tiene problemas con los polígonos irregulares. Las adosamos a la base con los datos de marginación. 

marginacion_tlaxcala <- cbind(marginacion_tlaxcala, 
                              as.data.frame(coordinates(tlaxcala_poly))) #coordinates() regresa una matríz, tengo que pasarla a df antes de pegarla. Automáticamente les asignará los nombres V1 y V2. 

ggplot(marginacion_tlaxcala, aes(map_id = id)) +  
  geom_map(aes(fill = IM), 
             map = tlaxcala_df) +  
  geom_text_repel(aes(x=V1, y=V2, label=MUN), size=2) +  #Con geom_repel para evitar overplotting. 
  expand_limits(x = tlaxcala_df$long, y = tlaxcala_df$lat) + 
  coord_map("lagrange") + 
  theme_minimal() + 
  scale_fill_continuous(low="green", high="red")

```

##Importación de capas adicionales.

Hay muchas formas de importar capas de datos adicionales. Aquí cubriremos una básica: importarlos directamente de GoogleMaps.
La función `get_map()` de `ggmap::` permite importar mapas de GoogleMaps, OpenStreetMap, Stamen Maps y CloudMade.
Debemos especificar las coordenadas que nos interesan como longitud-latitud (ene ese orden), el nive de zoon (donde 3 es un continente y 21 un edificio), el tipo de mapa ("terrain", "satellite", "roadmap", etc.). 

```{r}
library(ggmap) 
google_tlax_terreno <- get_map(
  location=c(-98, 19.4),     #Long y lat del centro del mapa que buscamos
  source="google",           #Fuente, tb OpenStreetView
  maptype="terrain",         #Tipo. También "satellite", "roadmap"
  zoom=9)                    #entre 1 y 21. 1 planisferia, 21 edificio. 

#Así lo visualizamos. 
ggmap(google_tlax_terreno)

#Agregamos una capa de divisiones políticas. 
ggmap(google_tlax_terreno) + geom_polygon(data=tlaxcala_poly, aes(x=long, y=lat, group=group), color="black", fill=NA) #Evito que rellene con gris. 
  
otro <- get_map(location = c(-99.1826, 19.378), source="google", maptype = "satellite", zoom = 20) 

#ggmap(otro)  + geom_label(x=-99.1826, y=19.3781, label="ÑOÑOS") + theme_void()
```

##Importación de rutas desde un teléfono celular. 

La importación dependerá del formato de salida de la aplicación que estemos usando. Las aplicaciones de GPS de los celulares generalmente permiten exportar las rutas en formato .kml (GoogleMaps) o GPX. En general importar .kml es R es complicado, porque hay encontrar el identificador de la ruta. Importar .gpx es más simple y por lo tanto el método preferido. 
Para esto último usamos la función `readGPX()` del paquete plotKML. El formato .gpx es una especificación de xml para guardar rutas. De un archivo .gpx tiene cinco columnas: longitud, latitud, elevación, tiempo (año, mes, día, hora, minuto, segundo) y extensiones, que en la lista que regresa `readGPX()` están en `$tracks`. 

El objetivo es plotear un mapa raster de la zona CDMX en la que está registrada una ruta y etiquetar algunos de los puntos con el tiempo acumulado desde la partida a la llegada. Lo primero es muy fácil, lo segundo no tanto, pues el manejo de horas y fechas no es fácil en R. 
Sin embargo lo podemos hacer con un anónimo agradecimiento a [este cuate.](http://rcrastinate.blogspot.mx/2014/09/stay-on-track-plotting-gps-tracks-with-r.html)

```{r}
library(plotKML)   #Levanta muchísimas dependencias en la instalación.

# Gráfico con inmutabilidad de datos. 
#1. Importo, 
#2. formateo el timestamp, 
#3. Genero la suma acumulada de diferencia en minutos. 
#4. Selecciono una fila cada 50
#Grafico con etiquetas. 
#Posibles mejoras de código: estudiar mutate lag() y resolver el problema de la suma acumulada. Básicamente el problema del NA.
#Un mejor sistema para seleccionar una fila cada 50 (o arbitrario)
#Pisibles mejoras de funcionalidad: calcular automáticamente el centro del mapa que va a pedir a la API de google. (esto es un problema de GIS)
#===========================

readGPX("19_feb._2017_10_54_56.gpx")$tracks[[1]][[1]][] %>% #Porque son 3 listas anidadas.
  mutate(
    time=as.POSIXct(                            #Porque mutate no acepta POSIXlt
      strptime(time,                            #Regresa POSIXlt
               format = "%Y-%m-%dT%H:%M:%OS")   #timestamp de gpx
               )
         ) %>% 
  mutate(acum=round(         
           cumsum(c(0,       #diff regresa length-1 y mutate() no acepta largos diferentes.  
             diff(time)      #Diferencia en x y x[-1]
                   )
                 )/60)) %>%  #Paso directo a minutos. 
           mutate(etiquetas=
                    ifelse(row_number(acum) %in%  seq(1,nrow(.), 50), #Selecciono 1 cada 30 filas. 
                           acum, 
                           NA)                                          #El resto a NA
                  ) -> ruta 

ggmap(get_map (location=c(-99.16, 19.431), source="google", maptype="terrain", zoom=13)) +
  geom_point(data=ruta, aes(x=lon, y=lat), size=.5) +  
  geom_label_repel(data=ruta, aes(x=lon, y=lat, label=etiquetas))
```


##Funciones mágicas. 

El paquete mxmaps, de [Diego Valle](https://www.diegovalle.net/mxmaps/index.html), permite hacer mapas coropléticos de México con una sintaxis simplificada. Los mapas que retoman los datos de las bases incluidas no requieren casi ninguna especificación, sin embargo para extender la funcionalidad es necesario conocer el funcionamiento la estructura de la base de datos incluída y agregar las columnas adecuadas. Dado que hay múltiples variables de índice podemos usar un join para agregar capas de datos.
La sintaxis básica para producir mapas a nivel municipios es `df_mxstate#value <- df_mxstate$variable_de_interés`, donde variable de interés es la que controlará el parámetro de color. Señalamos la variable de interés asignándola en la columna `$value`. Luego llamamos a la función `mxmunincipio_choroppleth(df_mxmunicipio)`, es decir, señalamos el data.frame incluido en la librería en el que previamente señalamos la variable de interés en `$values`. No es necesario especificar los polígonos, están incluidos por defecto. 
Para mapas a nivel Estados usamos el data.frame `df_mxstate` y `mxstate_choropleth()`. 


```{r, eval=FALSE}
#Instrucciones para instalar el paquete, es necesario ejecutarlo sólo una vez. 
#Mucha atención a los errores que regresa el instalador. El paquete tiene muchas dependencias no declaradas y hay que buscar cual produce el error, instalar ese paquete y así que hasta que funciona. 
#advertencia: el paquete es alpha, es decir, muy temprano en la etapa de desarrollo y aparentemente no tiene desarrollo activo.  ¿abandonado?
if (!require(devtools)) {
    install.packages("devtools")
}
devtools::install_github('diegovalle/mxmaps') #En mi compu no instala. :-(
```

```{r}
library(mxmaps)
#A nivel estatal. 

df_mxstate$value <- df_mxstate$pop
mxstate_choropleth(df_mxstate, title="Población por Estados")
mxhexbin_choropleth(df_mxstate, title="Población por Estados")  #Los presenta como hexágonos uniformes. 

#A nivel municipal. 

df_mxmunicipio$value <- df_mxmunicipio$pop_male - df_mxmunicipio$pop_female #Diferencia entre población masculina y femenina. 
mxmunicipio_choropleth(df_mxmunicipio, title="Diferencia entre población masculina y femina")

#Agregando datos no incluidos en el paquete.

marginacion$region <- marginacion$`<U+FEFF>CVE_MUN`
df_mxmunicipio <- inner_join(df_mxmunicipio, filter(marginacion, AÑO=="2015"), by="region") #Hago un join por Clave de Municipio y empato ambas bases. Filtro marginacion directamente en la llamada porque la transparencia referencial de R me lo permite. 
df_mxmunicipio %>% str()    #Le agregué todas las variables del IM. 

df_mxmunicipio$value <- df_mxmunicipio$GM     #GM lo trahe del otro data.frame
mxmunicipio_choropleth(df_mxmunicipio) +  
  labs(title="Grado de marginación municipal", 
       subtitle="Mapeado con mxmaps",
       caption="Datos estadísticos CONAPO\nDatos geográficos ¿?") +
  coord_map("azequalarea") +                 #No tengo idea de lo que estoy haciendo.
  scale_fill_manual(values=c("red", "orange", "yellow", "red4", "green"))
```

#Unas series de tiempo para ir calentando motores...
 
```{r, include=FALSE}
token <- "7bb701f8-91b3-2f96-4bcc-db5aea06d87c"   #Sáquese la suya en http://www3.inegi.org.mx//sistemas/api/indicadores/v1/tokenVerify.aspx 
```

```{r}
library(inegiR)     #Para extraer datos directamente del INEGI a R. 
library(ggpmisc)
series_produccion_autos(token) %>%     #Serie de producción de autos. 
  mutate(mes = format(Fechas, "%m"), anio = format(Fechas, "%Y")) %>% 
  group_by(anio) %>% 
  summarise(anual=sum(Autos)) %>% 
  ggplot(aes(x=anio, y=anual, group=1)) +  
  geom_line() + 
  labs(title="Producción anual de automóviles en México", subtile="Extracción de datos directa del INEGI", datos="INEGI") +  theme_minimal()


series_produccion_autos(token) %>% 
  ggplot(aes(x=as.POSIXct(Fechas), y=Autos, group=1)) +  
  geom_line() + 
    stat_peaks(geom = "text", size=3, angle = 90,hjust = -0.1, x.label.fmt = "%b%y",  ignore_threshold = 0.4, strict = T) + stat_valleys(geom = "text", size=3, angle = 90,hjust = 1.5, x.label.fmt = "%b%y",  ignore_threshold = 0.4, strict = T) + stat_smooth() + 
  theme_minimal() + labs(title="Producción mensual de automóviles en México", 
                         subtile="Ajuste por regresión local. Picos y valles.", 
                         datos="INEGI")  
```