---
title: "Series de tiempo en R"
author: "Martín Paladino^[mpaladino@mora.edu.mx]"
date: "8 de marzo de 2017"
output:
  html_document:
    fig_height: 8
    fig_width: 10
    highlight: kate
    theme: united
    toc: yes
lang: es-ES
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
token <- "7bb701f8-91b3-2f96-4bcc-db5aea06d87c" 
```

#Introducción. El objeto de este documento. 

Las series de tiempo son series de datos --en sentido estadístico: variables-- ordenadas por orden temporal y con algún tipo de índice que indica el tiempo al que corresponde esa observación. La secuencia comúnmente se organiza en puntos de tiempo con una separación igual, en ese caso son series tiempo con intervalos iguales. iguales. Las series de tiempo también tienen puede tener intervalos desiguales, cuando el evento que se registra no ocurre con una periodicidad establecida. Valgan como ejemplo un registro de exportaciones trimestrales  --con un dato por cada trimestre, así sea 0-- y las exportaciones registradas en año, mes, día, hora, segundo, registradas idealmente cada vez que se realiza una venta a un agente económico extranjero.^[Un ejemplo más claro: la serie de tiempo de las visitas al médico de una persona. No suceden en un intervalo regular.]

```{r}
#Librerías básicas.

library(tidyverse)
library(inegiR)       #Requiere token de INEGI

#Onda sonora. 

qplot(1:1000,rnorm(1000, 0, 10), geom="line") + 
  labs(x="Tiempo", 
  y="Presión", 
  title="Onda de sonido", 
  subtitle="Serie de tiempo") + 
  theme_minimal()
```

#Series de tiempo con datos económicos. 

##Agregar series de tiempo en años, semestres, trimestres.

En R expresamos una serie de tiempo con dos o más vectores, uno con el punto de tiempo y otro con el valor correspondiente. Es conveniente organizar estos vectores en una estructura data.frame, para asegurarnos que se mantengan alienados. Idealmente el vector índice de tiempo debe tener una fecha -y hora, minutos, segundos si aplica- completa: año, mes, día con separadores claros, respetando el mismo formato a lo largo de toda la serie. Si la marca de tiempo tiene el formato correcto es posible hacer agregar datos con facilidad.  
La librería `lubridate::`, de Hadley Wickham, tiene funciones para el manejo de fechas. Como es de esperar funciona muy bien con `dplyr::` y nos permite pasar los argumentos `year()`, `month()`, `semester()`, `quarter()`, `week()`, etc. a `group_by()`. La mayor dificultad es asegurarnos que el índice temporal es un objeto de la clase fecha (Date en R). Más adelante veremos formas de pasar un objeto a la clase Date. Por ahora usaremos series que descargadas con la librería `inegiR::`, que regresan un data.frame con la columna `Fechas` perfectamente formateada como fecha y con el atributo de clase correcto: `Date`.

```{r}
exportaciones <- 
  series_exportaciones_pais(token) #Descargo la serie de exportaciones de México y la asingo a exportaciones
head(exportaciones, 15)            #¿Qué hay?

library(lubridate)                 #Se carga también con library(tidyverse). 

class(exportaciones$Fechas)        #Clase de la columna Fechas. Es Date, no tendremos problemas. 
is.Date(exportaciones$Fechas)      #Otra forma de verificar que una columna de fechas esté en formato de fecha. Debe regresar TRUE




          #================================#
          #Agregados de series temporales. #
          #================================#


#Serie anualizada. year()
#========================
exportaciones %>% 
  group_by(year(Fechas)) %>%                      #Acá va la magia! Vieron que valía la pena aprender a usar dplyr...
  summarise(EEUU=sum(`Estados Unidos`),           #Sumo por grupos=años
            CAN=sum(Canada), CHI=sum(China), 
            CentroAmerica=sum(`Centro America`),
            Sudamerica=sum(`America del Sur`))

#Serie por semestre (semester)
#============================
exportaciones %>% 
  group_by(semester(Fechas)) %>%                    #Por semestre: generará dos grupos, uno por semestre de TODOS los años..
  summarise(EEUU=sum(`Estados Unidos`),             #Sumo por grupos=semestres
            CAN=sum(Canada), CHI=sum(China), 
            CentroAmerica=sum(`Centro America`),
            Sudamerica=sum(`America del Sur`))

#Serie por semestre de cada año. year(), semester(). Cálculo de medias
#=====================================================================

exportaciones %>% 
  group_by(year (Fechas), semester(Fechas)) %>%     #Por año y semestre. 
  summarise(EEUU=mean(`Estados Unidos`),            #Promedio semestral.
            CAN=mean(Canada), CHI=sum(China), 
            CentroAmerica=mean(`Centro America`),
            Sudamerica=mean(`America del Sur`))

#Serie por trimestre. quarter()
#==============================

exportaciones %>% 
  group_by(year (Fechas), quarter(Fechas)) %>%     #Por año y trimestre 
  summarise(EEUU=sd(`Estados Unidos`),             #Desviación estándar del trimestre.
            CAN=sd(Canada), CHI=sum(China), 
            CentroAmerica=sd(`Centro America`),
            Sudamerica=sd(`America del Sur`))
```

##Importar objetos de la clase Date. 

Las operaciones que hicimos y muchos gráficos específicos dependen de que la marca de tiempo de la serie temporal sea de la clase `Date`. Alternativamente `lubridate::` y `dplyr::` aceptan el formato `POSIXct`, una especificación de formatos de fechas desarrollada para los sistemas operativos UNIX. Podemos pasar fácilmente de `Date` a `POSIXct` con `as.Date()` y `as.POSIXct` respectivamente. 

Los datos descargados con `inegiR::`  traen los atributos correctos, pero esto es poco frecuente. Lo más usual es que obtener las fechas codificadas en cadenas de caracteres, que debemos convertir previamente a formato fecha. Dado que distintos datos pueden usar diferentes formatos de fechas no hay una solución general o una función mágica que lea las fechas de manera correcta. Tome en consideración las diferentes formas de registrar el 8 de marzo de 2017: 8-3-17, 08-03-2017, 08/03/2017, 20170308, 08-mar-2017, 03/08/2017. No se frustre, lograr pasar una fecha capturada como una cadena a la clase `Date` es difícil, pero una vez que lo haya logrado ahorrará mucho tiempo en la manipulación posterior. 
`lubridate::` incluye la función `parse_date_time()` que ayuda mucho al respecto, sólo debemos pasarle como primer argumento un vector de cadenas de caracteres con fechas y otra cadena con el orden de día, mes y año de esas fechas usando abreviaturas. `y` indica la posición del año, `m` la del mes y `d` la del día. Así para una fecha expresada como "8-3-17" el orden "dmy", día mes y año. La misma fecha expresada en el formato usual en EEUU sería `"03-08-2017", en la que el orden es `"mdy"`, mes, día, año. 
`lubridate::` tiene métodos abreviados de `parse_date_time()` en los que directamente llamamos a una función con el orden de la fecha que queremos convertir. Por ejemplo `ymd()` para año, mes, día. También `dmy()`, `myd()`, `ymd()`,  `dym()`, `mdy()`, `ymd_hms()`, este último con hora, minuto y segundo. Con los métodos abreviados no es necesario especificar el orden de la fecha dentro de la función, cada una es exclusiva para un orden.

```{r}
#Ejemplos de conversión de cadenas de caracteres a fechas. 
parse_date_time("8-3-17", "dmy") 
parse_date_time("08-03-2017", "dmy")
parse_date_time("03/08/2017", "mdy")    #Automáticamente identifica el separador /
parse_date_time("03082017", "mdy")      #También sin separador
parse_date_time("3817", "mdy")          #Falla y regresa NA, no puede identificar el formato. 
parse_date_time("08-marzo-2017", "dmy") #Se habla español.
parse_date_time("march-08-2017", "mdy", tz="Mexico/General") #Cambio la zona horaria. Útil si incluyo la hora. 
dmy("8-3-17")                           #Método abreviado.
ymd("17/marzo/3")                       #También habla español.

fechas <- paste(seq(1, 30, 2), 
                rep(seq(1, 12, 1), 3), 
                rep(seq(2010, 2017, 1), 3), 
                sep="/")                      #Genero un vector de fechas como cadenas. 
fechas
datos <- rnorm(length(fechas), 0, 1)          #Número aleatorios normales del mismo largo de fechas. 
serie_de_tiempo <- data.frame(fechas=fechas, datos=datos, stringsAsFactors = FALSE)
class(serie_de_tiempo$fechas)                 #Las fechas son caracter. 

#Dentro de cadenas de dplyr
#==========================

serie_de_tiempo %>% 
  mutate(fechas=dmy(fechas)) %>%             #Paso a la clase Date a fechas
  group_by(year(fechas)) %>%                 #dplyr es amor
  summarise(promedio_anual=mean(datos))


#Datos meteorológicos de la estación EMAS Tezontle del 1ro al 8 de marzo
#========================================================================

#El servicio meteorólogico no tiene API pública: a descargar exceles...  
library(readxl)
tezontle <- read_excel("C:/Users/mpaladino/Dropbox/Análisis Multivariado/Bases de Datos/Estación_Tezontle_Una_semana.xlsx")

tezontle$`AAAA/MM/DD HH:MM HORAZ` %>% class()                     #Es caracter.

tezontle %>% 
  mutate(fecha=ymd_hm(tezontle$`AAAA/MM/DD HH:MM HORAZ`)) %>%     #Paso a formato de fecha y hora con ymd_hm() 
  group_by(day(fecha))  %>%                                       #Agrupo por día.
  summarise(presion=mean(`Presión Atmosférica`, na.rm=TRUE), 
            temperatura=mean(`Temperatura del Aire (°C)`, na.rm=TRUE)) 

``` 

#Gráficos de series de tiempo. 

Las series de tiempo se grafican frecuentemente a través de líneas. En el eje x ubicamos la marca temporal y en el eje y el dato que nos interesa. 
Las series de tiempo registradas con frecuencias altas suelen tener altibajos constantes, similares a los que vemos en un electrocardiograma o sismógrafo (que son gráficos de series de tiempo). Una forma simple de visualizar la tendencia es fortificar nuestro gráfico con un modelo de regresión local. En `ggplot::` agregamos el elemento geométrico `geom_smooth()`.  

> No se recomienda emplear dos escalas para el eje y en el mismo gráfico. Para explorar las relaciones entre más de una serie de datos se pueden usar gráficos con paneles múltiples. 

```{r}

#Serie de tiempo multipanel.

tezontle %>% 
  mutate(fecha=ymd_hm(tezontle$`AAAA/MM/DD HH:MM HORAZ`)) %>% 
  select(-`AAAA/MM/DD HH:MM HORAZ`) %>% 
  gather(variable, dato, -fecha) %>% 
  ggplot(aes(x=fecha, y=dato)) + 
  geom_line() +  
  geom_smooth(se=F) +                                           
  facet_wrap(~variable, scales="free", ncol=1) +          #scales="free" para que cada panel tenga su propia escala.
  labs(caption="Datos de la Estación Tezontle del EMAS", 
       y="", 
       x="", 
       title="Clima en la Ciudad de México", 
       subtitle="No registra las lluvias del 4 de marzo") + 
  theme_minimal()

#Serie de tiempo multicolor: todos en la misma escala. 
series_exportaciones_pais(token) %>% 
  gather(País, Monto, -Fechas) %>%                         #Paso los datos a formato largo.
  ggplot(aes(x=Fechas, y=Monto, group=País, color=País)) + 
  geom_line() + 
  labs(title="Exportaciones de México", y="Miles de dólares a precios corrientes", caption="Datos: INEGI") + 
  theme_minimal()
```


#Descomposición de series de tiempo.

R incluye varios métodos para descomponer series de tiempo. El problema técnico es obtener un objeto de la clase `ts`, time series. Una vez que tenemos este objeto usamos `decompose()` para ajustar el modelo, al que podemos especificar como aditivo o multiplicativo. Con `stl()` podemos ajustar modelos más sofisticados.  
Los objetos de la clase `ts` son casi una reliquia y requieren algo de esfuerzo. Especificamos un objeto `ts` con la función `ts()` a la que pasamos un vector de valores --sin fecha--, la fecha de inicio y la periodicidad en meses. Funciona para series de tiempo con intervalos iguales. 

##Objetos de la clase `ts`

```{r, warning=FALSE}
#Descomposición de series de tiempo. 
#====================================

#Crear un objeto de la clase ts: serie de tiempo. 

exportaciones_eeuu_ts <- 
  ts(exportaciones$`Estados Unidos`,          #selecciono la columna de EEUU. 
                            frequency = 12,   #La series es mensual, 12 puntos de datos.   
                            start=c(1993, 1), #Inicio de la serie como vector c(año, mes)
                            end=c(2016, 12))  #Fin de la serie

class(exportaciones_eeuu_ts)                  #Pertenece a la clase ts

#Aplicar una descomposición aditiva. 

str(decompose(exportaciones_eeuu_ts))         #Descomposición de la serie, por defecto aditiva.
```

##Gráficos de descomposición de series de tiempo. 

```{r, warning=FALSE, message=FALSE}
#Gráfico estándar de la serie descompuesta. NO ggplot2.

plot(decompose(exportaciones_eeuu_ts))      


#Gráfico de serie de tiempo descompuesta con ggplot2. 

library(ggfortify)          #Requerida para pasar un objeto decomposed.ts a data.frame. Importa método autoplot.
library(hrbrthemes)         #Importa theme_ipsum() y scale_y_comma()

#Básico: nombres en inglés. 
autoplot(decompose(exportaciones_eeuu_ts)) +  
  labs(title="Exportaciones a Estados Unidos", 
       subtitle="Descomposición aditiva", 
       caption="Datos INEGI") + 
  theme_minimal()

#Modificado para nombres en español. Retocado para publicación. 

fortify(decompose(exportaciones_eeuu_ts)) %>% #Convierte a la serie de tiempo descompuesta a data.frame             
  rename("Datos"=Data,                        #Aquí cambio los nombres de columna.
         "Estacional"=seasonal, 
         "Tendencia"=trend, 
         "Residuo"=remainder) %>%
  gather(variable, valor, -Index) %>%        #Paso a formato largo con gather(), mantengo Index.
  ggplot(aes(x=Index, y=valor)) +            #Mapeo x y y 
  geom_line() +                              #Elemento geométrico  
  facet_grid(variable~., scales="free") +    #especifico los paneles. facet_grid etiquetado horizontal
  labs(title="Exportaciones a Estados Unidos", 
       subtitle="Descomposición aditiva", 
       caption="Datos INEGI", 
       x="Tiempo", 
       y="Miles de dólares de Estados Unidos") +   
  theme_ipsum() + 
  scale_y_comma()
```

