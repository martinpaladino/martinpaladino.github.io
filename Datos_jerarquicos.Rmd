---
title: "Agregar un nivel de agrupamiento a una base de datos existente"
author: "Martín Paladino"
date: "25 de febrero de 2017"
output: 
  html_document: 
    highlight: textmate
    number_sections: yes
    theme: flatly
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

>Never do loops and roll a join from time to time.

#Definición general del problema. 

Con frecuencia los datos con los que trabajamos están agrupados, es decir, se pueden dividir en múltiples cateogrías. Algunos de estos agrupamientos son sólo eso, categorías que podemos cruzar como mejor nos parezca. Sin embargo, en algunos casos esos grupos guardan un orden de pertenencia estricto: todos los datos de cierto grupo pertenecen a su vez a un grupo más amplio y al mismo tiempo no pertenecen a ningún otro. Veamos un ejemplo en dos tablas: 

Table: Datos mutuamente independientes

Fila | Nivel educativo| Género
-----|----------------|----------
1    |Primaria        | Masculino
2    |Universidad     | Masculino
3    |Primaria        | Femenino
4    |Secundaria      | Femenino
5    |Primaria        | Femenino
6    |Primaria        | Masculino 

Table: Datos jerárquicos

Fila |Continente | País
-----|-----------|---------------
1    |América    | México
2    |América    | Jamaica
3    |América    | Uruguaguay
4    |Europa     | Croacia
5    |Europa     | Luxemburgo
6    |Europa     | San Marino 

En la Tabla 1 uno podemos agrupar los datos: las filas 1, 5 y 6 de la columna nivel educativo son el grupo "Primaria", las filas 3 a 5 de la columna "Género" son el grupo femenino. Sin embargo los grupos cruzados que obtenemos no son mutuamente excluyentes, 1 y 5 pertenecen al grupo "Primaria", pero a dos grupos diferentes de género. La Tabla 2 forma grupos en una estructura jerárquica: cada país correponde sólo a un continente. 

El problema práctico que queremos resolver es agregar a una base de datos una nueva colunma en la que incluyamos un nuevo nivel de agrupamiento jerárquico. El primer paso es verificar que nuestros datos tengan una estructura jerárquica, de lo contrario estamos ante un problema diferente. Cada fila de los datos originales debe pertenecer a uno y sólo uno de los grupos que queremos agregar. 

En este ejemplo práctico tomaremos la base de CONAPO del Índice de Marginación a nivel municipal, que ya incluye un órden jerárquico de Entidades y Municipios. Cada municipio pertenece solamente a una entidad. Queremos agregar las regiones a las que pertenece cada entidad, un nivel de jeraquía más alto. Es necesario, por lo tanto, conocer a qué región pertenece cada Entidad.

#Agregar un nivel jerárquico más amplio usando R. 

Hay varias aproximaciones a este problema. La más directa y laboriosa es editar manualmente los datos y agregar la región a cada fila. Con 14646 filas en total no es una gran idea, llevaría mucho tiempo y además este procedimiento es propenso a errores. Mejor automatizar el proceso.
Para automatizarlo también tenemos varias opciones. En cualquier de las opciones al menos dos estructuras de datos, la base con la información de Entidades y Municipios y alguna otra estructura que especifica a qué región pertenece cada Entidad. Luego debemos pasar esos datos a alguna función o funciones para que cree la fila "REGION" con el nombre de la región que corresponde, alineado en la fila de la entidad pertinente. La columna REGION deberá tener un largo de 14646, es decir, el mismo largo que la base de datos. 

```{r}
library(tidyverse)
library(knitr)
#Cargamos la base de datos. Modificar la ubicación del archivo si es necesario. 
base_marginacion <- read_csv("C:/Users/mpaladino/Downloads/Base_Indice_de_marginacion_municipal_90-15.csv",col_types = cols(`AÑO` = col_character())) %>%
  select(-`<U+FEFF>CVE_MUN`, -CVEE_MUN, -VP) %>%
  mutate (POB_TOT=gsub(" ","", POB_TOT)) %>% 
  mutate(POB_TOT=as.integer(POB_TOT)) %>% filter(ENT!="Nacional")
``` 

Una  primera aproximación es usar una función de recodificación condicional. La condición que vamos a verificar es de pertenencia, por lo que usaremos el operador `%in%` que verifica si un elemento pertenece o no a un conjunto y regresa `TRUE` o `FALSE` según sea el caso. El conjunto al que los Entidades pertenecerán o no está definido por cada región. Como el número de Entidades por región es desigual no es viable usar una estructura rectangular como el data.frame, por lo tanto definiremos a cada conjunto/región como un vector atómico para mantener las cosas simples^[Podriamos hacer una lista, pero introduce una complejidad adicional innecesaria para este ejemplo.] El vector Sur_oeste incluye a los Estados de Chiapas, Oaxaca y Guerrero, y así con los 7 restantes. Es fundamental cometer ningún error ortográfico, de espacio, puntuación, etc. Para el evaluador lógico de R `Mexico` y `México` son completamente diferentes. El siguiente paso es programar una función que verifique fila por fila el nombre de la Entidad -la colunma ENT-, revise a qué conjunto/vector pertenece y asigne el nombre del vector correcto en la columna REG de cada fila.  

##Opción 1. Un bucle. 

La opción 1 es una forma muy clásica de programar una función para que haga algo si se cumple cierta condición. Usamos dos estructuras de control anidadas: la estrucura `for()` para hacer que el evaluador de R circule fila por fila. En cada paso del bucle el índice `i` aumenta una unidad, partiendo de 1 hasta llegar a `nrow(base_marginacion)` o 14646. En cada paso/fila evalúa los 8 `if` y, cuando se cumple la condición (es decir, la Entidad pertenece al vector en cuestión) asigna con `=` el nombre correcto en `$REG`. Modifica directamente la estructura de datos base_marginacion, es decir, como función no tiene un output, sólo produce efectos secundarios. Las posibilidades de que un error de sintaxis o de concepto en la definición de la función corrompa los datos son altísimas.
El procesamiento de esto 9 bucles es muy lento. El evaluador tiene para pasar por cada una de las 14646 y evaluar 8 condiciones con 32 resultados posibles. Además R es conocido en el mundo de la programación por su lentitud para procesar estructuras recursivas. **Debemos evitar este tipo de programación siempre.** Seguramente habrá una función vectorizada que haga lo mismo, mucho más rápido y eliminando la posibilidad de corromper los datos.   


```{r}
#Generamos un conjunto vectores con la jerarquía de Regiones y entidades. 
Noroeste <- c("Baja California", "Baja California Sur", "Chihuahua", "Durango", "Sinaloa", "Sonora")
Noreste <- c("Coahuila de Zaragoza","Nuevo León","Tamaulipas") 
Oeste <- c("Colima","Jalisco", "Michoacán de Ocampo","Nayarit") 
Este <- c("Hidalgo","Puebla","Tlaxcala","Veracruz de Ignacio de la Llave") 
Centro_norte <- c("Aguascalientes", "Guanajuato","Querétaro de Arteaga","San Luis Potosí","Zacatecas")
Centro_sur <- c("Distrito Federal","México","Morelos")
Sur_oeste <- c("Chiapas","Guerrero","Oaxaca")
Sur_este <- c("Campeche", "Quintana Roo","Tabasco","Yucatán")

#Opción 1. Un bucle. Solución en R MUY base. Dos malas prácticas de programación en una: bucles y efectos secundarios. 

for(i in 1:nrow(base_marginacion)){           #i es el índice, 1:nrow es una secuencia de enteros de 1 hasta el número de filas de la base de datos (14646)
  if (base_marginacion$ENT[i] %in% Noroeste){
    base_marginacion$REG[i] = "Noroeste"}
  if (base_marginacion$ENT[i] %in% Noreste){
    base_marginacion$REG[i] = "Noreste"}
  if (base_marginacion$ENT[i] %in% Oeste){
    base_marginacion$REG[i] = "Oeste"}
  if (base_marginacion$ENT[i] %in% Este){
    base_marginacion$REG[i] = "Este"}
  if (base_marginacion$ENT[i] %in% Centro_norte){
    base_marginacion$REG[i] = "Centro_norte"}
  if (base_marginacion$ENT[i] %in% Centro_sur){
    base_marginacion$REG[i] = "Centro_sur"}
  if (base_marginacion$ENT[i] %in% Sur_oeste){
    base_marginacion$REG[i] = "Sur_oeste"}
  if (base_marginacion$ENT[i] %in% Sur_este){
    base_marginacion$REG[i] = "Sur_este"}
}

#Verificación: cantidad de municipios por región.

base_marginacion %>% group_by(REG, ENT) %>% tally() %>% kable()

```


##Opción 2. Una función condicional vectorizada. 

En este caso usamos `case_when()`, una función que hace lo mismo que nuestro bucle: pasar por cada fila de un data.frame, ver si en una columna se cumple una condición y asignar un valor. Es una función especializada, está programada de modo tal que siempre evalua a lo largo de una columna de un data.frame, por lo que no tenemos que indicarle explícitamente que lo haga. La sintaxis es bastante más corta y clara: separadas por comas van las condiciones del lado izquierdo y a la derecha de `~` el resultado que se registra si la condición se cumple. Se ejecuta 10 veces más rápido que el bucle, es más legible y fácil de modificar en caso necesario. En el bucle si quiero cambiar el nombre de la variable de REG a "Región" necesito modificar 8 líneas, aquí con cambiar REG por "Región" al principio basta. El resultado es el mismo. 

```{r}
#Opción 2. Función vectorizada dplyr::case_when(). 


#Empiezo por importar nuevamente la base, ya que el código anterior la modificó. 

base_marginacion <- read_csv("C:/Users/mpaladino/Downloads/Base_Indice_de_marginacion_municipal_90-15.csv",col_types = cols(`AÑO` = col_character()), locale = locale(encoding = "UTF-8")) %>%
  select(-`<U+FEFF>CVE_MUN`, -CVEE_MUN, -VP) %>%
  mutate (POB_TOT=gsub(" ","", POB_TOT)) %>% 
  mutate(POB_TOT=as.integer(POB_TOT)) %>% 
  filter(ENT!="Nacional")


base_marginacion %>% 
  mutate(REG=case_when(
    .$ENT %in% Noroeste ~ "Noroeste",
    .$ENT %in% Noreste ~ "Noreste", 
    .$ENT %in% Oeste ~ "Oeste",
    .$ENT %in% Este ~ "Este", 
    .$ENT %in% Centro_norte ~ "Centro_norte", 
    .$ENT %in% Centro_sur ~ "Centro_sur", 
    .$ENT %in% Sur_oeste ~ "Sur_oeste", 
    .$ENT %in% Sur_este ~ "Sur_este"
  )) %>% #Aquí también podriamos asignar un nombre a la salida con ->
  group_by(REG, ENT, CVE_ENT) %>% 
  tally()
```


##Opción 3. Un join de bases de datos. 

Una tercera aproximación es usar que realiza un procedimiento totalmente diferente, un join. Los joins son sumamente útiles en procesamiento de datos, nos sirven para integrar mútiples bases de datos. `dplyr::` permite hacer diferentes tipos de joins: completos, parciales, aún negativos. En este caso usamos inner_join, que es el más estricto de todos y solamente conserva las filas en las que hay empates perfectos en los valores de ambas bases de datos. Nos sirve para asegurarnos que el resultado es correcto, el data.frame resultante debería tener el mismo número de filas que el más largo (base_marginacion). Si tiene menos filas algo ha salido mal. 

>Nota sobre `dplyr::*_join`. Tiene un problema grave cuando la columna de empate (definida con `by=` dentro de la función) tiene cadenas de caracteres que incluye caracteres no ASCII, es decir, acentos o letras como la ñ o ç. Si no nos aseguramos que las estructuras de datos que queremos unir tengan exactamente la misma codificaciones de caracteres join no va a encontrar conicidencia. Por consiguiente se recomienda hacer siempre joins unsando claves numéricas o alfanuméricas. Más allá de este problema de `dplyr::*_join()` es una buena práctica usar claves y no nombres, ya que se reduce la posibilidad de errores de tipeado. Recuerde que para R México $\neq$ Mexico.

```{r}
#Opción 3: un join.

#Primero creo un data.frame con los nombres cortos de las Entidades Federativas, que pueden ser útiles para salidas gráficas, la clave INEGI de entidad y la región a la que pertenecen. Uso tribble que organiza la entrada en columnas y hace más legible la información que estamos cargando, pero podría usar data.frame() y otra función similar. Si quiero conservar esta tabla (que sin dudas será de utilidad) podría exportarla a un archivo .csv 

tribble(~REGION,        ~ENT_CORTO,           ~CVE_ENT,
        "Centro_norte", "Aguascalientes",     "01",     
        "Centro_norte", "Guanajuato",         "11",    
        "Centro_norte", "Querétaro",           "22",     
        "Centro_norte", "San Luis Potosí",    "24",    
        "Centro_norte", "Zacatecas",          "32",     
        "Centro_sur",   "Ciudad de México",   "09",    
        "Centro_sur",   "México",             "15",     
        "Centro_sur",   "Morelos",            "17",    
        "Este",         "Hidalgo",            "13",     
        "Este",         "Puebla",             "21",    
        "Este",         "Tlaxcala",           "29",     
        "Este",         "Veracruz",           "30",    
        "Noreste",      "Coahuila",           "05",     
        "Noreste",      "Nuevo León",         "19",    
        "Noreste",      "Tamaulipas",         "28",     
        "Noroeste",     "Baja California",    "02",    
        "Noroeste",     "Baja California Sur","03",     
        "Noroeste",     "Chihuahua",          "08",    
        "Noroeste",     "Durango",            "10",     
        "Noroeste",     "Sinaloa",            "25",    
        "Noroeste",     "Sonora",             "26",     
        "Oeste",        "Colima",             "06",    
        "Oeste",        "Jalisco",            "14",     
        "Oeste",        "Michoacán",          "16",    
        "Oeste",        "Nayarit",            "18",     
        "Sur_este",     "Campeche",           "04",    
        "Sur_este",     "Quintana Roo",       "23",     
        "Sur_este",     "Tabasco",            "27",    
        "Sur_este",     "Yucatán",            "31",     
        "Sur_oeste",    "Chiapas",            "07",    
        "Sur_oeste",    "Guerrero",           "12",     
        "Sur_oeste",    "Oaxaca",             "20" 
        ) ->tabla_regiones  #Le asigno nombre.


#¿A ver?

kable(tabla_regiones)

#Podemos guardar la tabla en un archivo de valores separados por comas para usarla en otros proyectos. 

#write.csv(tabla_regiones, "~/tabla_regiones.csv", fileEncoding="UTF-8") #Quitas el primer # para que se ejecute. 

#Ejecución del join. 
#===================

inner_join(base_marginacion, tabla_regiones, by="CVE_ENT") %>% 
  group_by(REGION, ENT_CORTO) %>% 
  tally() %>% 
  select(-n) %>% 
  kable(., caption="Estados por regiones") 

#uso dentro de una cadena de dplyr ¿Cuántos habirtantes tiene cada región?
#=========================================================================

inner_join(base_marginacion, tabla_regiones, by="CVE_ENT") %>% 
  group_by(REGION) %>% 
  tally(wt=POB_TOT) %>% 
  arrange(desc(n)) %>% 
  kable(., caption="Habitantes por regiones")
```


##Tiempos de ejecución. 

```{r, echo=FALSE}

system.time(for(i in 1:nrow(base_marginacion)){           #i es el índice, 1:nrow es una secuencia de enteros de 1             hasta el número de filas de la base de datos (14646)
              if (base_marginacion$ENT[i] %in% Noroeste){
                base_marginacion$REG[i] = "Noroeste"}
              if (base_marginacion$ENT[i] %in% Noreste){
                base_marginacion$REG[i] = "Noreste"}
              if (base_marginacion$ENT[i] %in% Oeste){
                base_marginacion$REG[i] = "Oeste"}
              if (base_marginacion$ENT[i] %in% Este){
                base_marginacion$REG[i] = "Este"}
              if (base_marginacion$ENT[i] %in% Centro_norte){
                base_marginacion$REG[i] = "Centro_norte"}
              if (base_marginacion$ENT[i] %in% Centro_sur){
                base_marginacion$REG[i] = "Centro_sur"}
              if (base_marginacion$ENT[i] %in% Sur_oeste){
                base_marginacion$REG[i] = "Sur_oeste"}
              if (base_marginacion$ENT[i] %in% Sur_este){
                base_marginacion$REG[i] = "Sur_este"}
            }) -> opcion1


base_marginacion %>% 
  mutate(REG=case_when(
    .$ENT %in% Noroeste ~ "Noroeste",
    .$ENT %in% Noreste ~ "Noreste", 
    .$ENT %in% Oeste ~ "Oeste",
    .$ENT %in% Este ~ "Este", 
    .$ENT %in% Centro_norte ~ "Centro_norte", 
    .$ENT %in% Centro_sur ~ "Centro_sur", 
    .$ENT %in% Sur_oeste ~ "Sur_oeste", 
    .$ENT %in% Sur_este ~ "Sur_este"
  )) %>% system.time() ->opcion2

inner_join(base_marginacion, tabla_regiones, by="CVE_ENT") %>% system.time() ->opcion3
rbind(opcion1, opcion2, opcion3) %>% as.data.frame %>% kable(., caption="Tiempos de ejecución en centésimas de segundo.")
```

Con más de 5 segundos de tiempo de ejecución el bucle es la peor opción. case_when e inner_join son tan rápidos que la función `Sys.time()` no reporta sus tiempos de ejecución por ser menores a 0.01 segundos. Una prueba de desempeño más detallada arroja 8 nanosegundos para case_when y 20 nanosegundos para inner_join. 
Es decir, en el tiempo en que se ejecuta case_when para esta base de datos en esta computadora un fotón recorre 2.4 metros, en el de inner_join 6 metros y para el bucle entre un millón y medio y dos millones de kilómetros, es decir, a mitad de camino de la luna.  

#¿Cuál usar?

Claramente no usaremos el bucle. Es el más lento, el código es de dificil mantenimiento y tiene efectos secundarios.^[Se podría programar ese bucle haciendo que genere un vector que luego podemos adosar a la base de datos. Aún así sería más lento.] En R **nunca usamos un bucle**.

`case_when()` e `inner_join()` están cercanos en velocidad, así que tendremos que usar otro criterio para seleccionar. Me inclino por usar un join. 

- Tiene una sintaxis más corta y simple que case_when (menos sintaxis, menos errores).
- Nos permite mantenernos usando data.frames, en lugar de generar vectores.
- Por eso podemos reciclar las tablas de claves y usarlas en otros proyectos. 
- Es más flexible: hay varios tipos joins que nos permiten hacer cosas diferentes, lo que necesitemos en cada caso. 
- Si esto fuera poco aprender los joins útiles para muchas más cosas: podemos usar el mismo procedimiento para unir dos bases de datos del INEGI por clave de entidad, municipio, localidad o AGEB. Eso queda para la próxima.  

#Bonus: joins con dplyr::

Para resolver el problema que teníamos `inner_join()` era la mejor opción, sin embargo dplyr:: inlcuye una familia de funciones join que aplican a casos diferentes. 

Table: Funciones de empate de bases de datos de `dplyr::`


Función          | Regresa:
-----------------|---------------------------------------------------------------------
inner_join (x,y) | Todas las columnas de x y y. Solamente las filas de en las que la clave de x y y coincide. Elimina las filas que nos tienen coincidencia. 
full_join(x,y)   | Todas las filas de x y y. Cuando hay coincidencia las empata, cuando no rellena con NA.
left_join        | Las filas de x y solamente las columnas de x. Rellena faltantes con NA. 
semi_join        | Regresa solamente las columnas y filas de x cuando hay coincidencia con y. 
anti_join        | Regresa las columnas de y las filas de x que no coinciden con y.


```{r}
#Para evitar empates perfectos y ver las diferencias vamos a eliminar las 10 primeras filas de tabla_regiones

tabla_regiones2 <- tabla_regiones [11:32,]

# 10,664 filas que coinciden en x y y, 23 columnas (x+y)
inner_join (base_marginacion, tabla_regiones2, by="CVE_ENT")

#14,641 filas de x o ý 23 columnas (21 de x, 3 de y - 1 que coincide)
full_join (base_marginacion, tabla_regiones2, by="CVE_ENT")

#14,664 filas de, 23 columnas de x y y.  
left_join (base_marginacion, tabla_regiones2, by="CVE_ENT") 

#10,664 filas de x y y, sólo las 21 colunmas de x.
semi_join (base_marginacion, tabla_regiones2, by="CVE_ENT") 

#3,977 filas en x y no en y, columnas de y. 
anti_join (base_marginacion, tabla_regiones2, by="CVE_ENT") 
```

¡Ah! El ejercicio 8.1 de la clase 5.

```{r}
#Con tabla_regiones cargada:

inner_join(base_marginacion, tabla_regiones, by="CVE_ENT") %>% 
  mutate(ANIO=AÑO) %>%      #Pq group_by tiene problemas (a veces) con los acentos y ñ. 
  group_by(REGION, ANIO) %>% 
  summarise (mediaIM=mean(IM)) %>% 
  qplot(ANIO, mediaIM, group=REGION, color=REGION, data = ., geom="line")
```
