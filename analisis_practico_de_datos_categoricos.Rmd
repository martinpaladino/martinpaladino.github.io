---
title: "Análisis práctico de datos categóricos"
author: "Martín Paladino"
date: "21 de marzo de 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning = FALSE, fig.width = 8, fig.height = 8)
arreglar_y_unir <- function(.) {
  separate(.,integrantes, into=("cabeza_coalicion")) %>%                  
  mutate(partido_coalicion=ifelse(is.na(cabeza_coalicion), partido, cabeza_coalicion)) %>%   
    mutate (id_estado= ifelse(str_length(id_estado)==1, 
                            paste0("0", id_estado), 
                            id_estado)) %>% 
  mutate(id_municipio= ifelse(str_length(id_municipio)==1, 
                              paste0("00", id_municipio),
                              ifelse(str_length(id_municipio)==2, 
                                     paste0("0", id_municipio), 
                                     id_municipio))) %>% 
  mutate(CVEMUN=paste0(id_estado, id_municipio)) %>% 
  inner_join(., marginacion) %>% 
  return(.)}
```

#Introducción. 
Este documento acompaña al más teórico [Introducción al análisis de datos categóricos con R](https://martinpaladino.github.io/Datos_categoricos.html). Presenta un ejemplo práctico de análisis exploratorio de datos categóricos con una base de datos real, la que prepara el Instituto Nacional para el Federalismo y el Desarrollo Municipal compilando información sobre presidentes municipales en México. Se trabajan paralelamente los problemas de análisis de datos con los de manipulación de datos que surgen con frecuencia en el análisis. 

##La base de datos. 

La base de datos primaria sobre la que trabajaremos es elaborada por el Sistema Nacional de Información Municipal y está disponible en formato .csv en http://www.snim.rami.gob.mx/

Trabajaremos especialmente con dos variables, el género de las y los presidentes municipales y el partido político al que representan. 

```{r}
#Importación de la base de datos. 
library(tidyverse)
library(pander)
library(forcats)
library(stringr)
presidentes_municipales <- 
  read_csv("./datos/presidentes_municipales.csv", col_types = cols(ap_materno = col_character(), fecha_actualizacion = col_character(), pdo_gob_ini = col_character()))

presidentes_municipales
```

# Género y partido político. 

```{r}
table(presidentes_municipales$partido, presidentes_municipales$sexo) %>% pander()
```

Esta tabla tiene varios problemas. 

1. La diferencia en las cantidades de municipios gobernados por partido complica dificulta la interpretación. Sería mejor expresar los conteos como proporciones de fila: ¿qué proporción de hombres y mujeres representan en el gobierno a cada partido? 

2. Tiene demasiadas filas. Hay muchos partidos pequeños que tiene sólo una presidencia municipal. Sería conveniente compactarlos en la categoría "Otros".

3. La categoría modal es "COAL.", es decir, una coalición de partidos. No sabemos qué partidos la integran, así que valdría la pena recuperar la información de la columna `integrantes` en la misma base de datos. 

Comenzaremos por atender cada punto. 

1. R inlcuye la función `prop.table()`, que toma como input a una tabla y regresa coo output una tabla con la misma estrucura, excepto que con los las proporciones en lugar de los conteos. 
La sintaxis básica de la función es `prop.table(tabla, margen)`. Donde tabla es un objeto de la clase tabla, creado con la función `table()` o `xtabs()` y margen es un número que señala el márgen respecto al cuál se computará la proporción. Usamos `1` para proporciones sobre filas y `2` para proporciones sobre columnas. El valor por defecto es `NULL` y calcula las proporciones sobre el total de la tabla. 

```{r}
#panderOptions('digits', 2)
panderOptions('round', 2)  #Establezco el nivel de redondeo para pander()
presidentes_municipales %$%    #Paso los datos como un entorno de vectores.
  table(partido, sexo) %>%     #Creo la tabla.  
  prop.table(., 1) %>%         #Creo las proporciones de fila. 
  pander(., "Proporción de género por partido")
```

2. El segundo problema no es de tablas, es un problema de codificación. Es decir, necesitamos recodificar la variable `partido` de tal modo que que se reduzca el número de categorías. Una posibilidad es hacerlo manualmente con la función `dplyr::recode()`.  Sin embargo la función `forcats::fct_lump()`  se dedica especialmente a compactar factores pasando determinadas categorías a una residual llamada "Otros". En lugar de especificar que categorías pasan a "Otros" le indicamos cuantas categorías queremos que queden. Consevará n-1 categorías, aquellas con mayor número de observaciones, y creará la categoría "Otros" en la que estarán todas demás reunidas. 

```{r}
library(forcats)
presidentes_municipales %>%
  mutate(partido=fct_lump(partido, n=20, other_level="Otros")) %$% 
  table(partido, sexo) %>%     
  prop.table(., 1) %>%         
  pander(., "Proporción de género para 19 partidos y Otros")

presidentes_municipales %>%
  mutate(partido=fct_lump(partido, n=10, other_level="Otros")) %$% 
  table(partido, sexo) %>%     
  prop.table(., 1) %>%         
  pander(., "Proporción de género para 9 partidos y Otros")
```

3. El tercer problema es el más complejo, pues implica tanto problemas técnicos de manejo de cadenas de caracteres como decisiones metodológicas de imputación de datos. La variable `integrantes` tiene como valor una cadena de caracteres con las abreviaturas de los partidos integrantes de la coalición separadas por guiones medios `-`.  Primero debemos ubicar en columnas separadas a cada partido integrante. Utilizaremos la librería `stringr::`^[¿Adivinen quién la escribió?], que reúne varias funciones de sintaxis simple para hacer operaciones sobre cadenas de caracteres. 


```{r}

library(stringr)
#Conteo de partidos por coalición. 
str_count(presidentes_municipales$integrantes, "-") %>% #str_count() nos regresa el número de veces que aparece un caracter o cadena. En este caso '-'. 
  max(., na.rm=T)                                       #Máximo de partidos que forman una coalición: 6. 

#Tabla partido~sexo con partidos imputados por coalición. 
presidentes_municipales %>% 
  separate(integrantes, into=("cabeza_coalicion")) %>%                      #Separo la columna integrantes en 6, el máximo de partidos en una coalición. 
  mutate(partido_coalicion=ifelse(is.na(cabeza_coalicion), partido, cabeza_coalicion)) %>%    #Integra las columnas partidos y partido1. Si no es partido sólo imputo la cabeza de coalición. 
  select(partido_coalicion, sexo) %>%                                         #Selecciono las variables. 
  table() %T>%                                          #Tubería en T         
  print() %>%                                           #Imprimo tabla
  summary()                                             #Obtengo el sumario


#Tabla partido~sexo con partidos imputados por coalición: 7 partidos más otros. 
presidentes_municipales %>% 
  separate(integrantes, into=("cabeza_coalicion")) %>%                        
  mutate(partido_coalicion=ifelse(is.na(cabeza_coalicion), partido, cabeza_coalicion)) %>%   
  mutate(partido_coalicion=fct_lump(partido_coalicion, n=8)) %>% 
  select(partido_coalicion, sexo) %>%                                      
  table() %>% 
  {. ->foo; pander(foo);plot(foo, shade=T); summary(foo)}           #lambda

#Join con base marginación. 
#Cargo base Marginacion. 

marginacion <- 
  read_csv("./datos/Base_Indice_de_marginacion_municipal_90-15.csv", col_types = cols(`AÑO` = col_character()), 
    locale = locale(encoding = "UTF-8")) %>%  
      mutate (POB_TOT=gsub(" ","", POB_TOT)) %>%
      mutate(POB_TOT=as.integer(POB_TOT)) %>%
      filter(ENT!="Nacional" & AÑO=="2015")
names(marginacion)[1] <- "CVEMUN" 

#Relación partidos/sexo condicional a GM. Gráfico. 
presidentes_municipales %>% 
  arreglar_y_unir() %>% 
  select(partido_coalicion, sexo, GM) %>% 
  group_by(partido_coalicion, sexo, GM) %>% 
  tally() %>% 
  ggplot(aes(y=n, x=partido_coalicion, fill=sexo)) + 
  geom_col(position="dodge") + 
  facet_wrap(~GM) + 
  theme_minimal() + 
  theme(axis.text.x = element_text(angle=90, size=5))
  
#Relación partidos/sexo condicional a GM. Descomposición chi^2
#Cortesía de Marius@stackoverflow

presidentes_municipales %>% arreglar_y_unir() %>% 
  select(GM, sexo, partido_coalicion) %>% 
  mutate(partido_coalicion=fct_lump(partido_coalicion, n=7))  %>% 
  group_by(GM) %>% 
  summarise(pvalue= chisq.test(sexo, partido_coalicion)$p.value) %>% 
  pander(., caption="Independencia estadística condicional al Grado de Marginación")

#Relación partidos/sexo condicional a ruralidad. 

presidentes_municipales %>% arreglar_y_unir() %>% 
  select(`PL<5000`, sexo, partido_coalicion) %>%
  mutate(partido_coalicion=fct_lump(partido_coalicion, n=7))  %>% 
  mutate(rural=ifelse(`PL<5000`>90, "Sí", "No")) %>% 
  select(-`PL<5000`) %>% 
  nest (-rural) %>% 
  mutate(tabla=map(data, ~table(.))) %>% 
  mutate(valorp=map(tabla, ~chisq.test(.)$p.value)) %>% 
  select(rural, valorp) %>% 
  unnest() %>% 
  pander(., caption="Independencia estadística condicional a Ruralidad")
```


